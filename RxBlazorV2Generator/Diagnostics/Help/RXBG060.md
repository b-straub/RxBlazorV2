# RXBG060: Direct Inheritance from ObservableComponent is Not Supported

## Description

This diagnostic is reported when a Razor component directly inherits from `ObservableComponent` or `ObservableComponent<TModel>` in the razor file. Direct inheritance is not supported. Instead, you should use the `[ObservableComponent]` attribute on your model class to generate a component class, then inherit from that generated class.

## Cause

This error occurs when:
- A `.razor` file uses `@inherits ObservableComponent` or `@inherits ObservableComponent<TModel>`
- The component directly references the base `ObservableComponent` class
- You haven't used the attribute-based component generation pattern

## How to Fix

Follow these steps:

1. **Add `[ObservableComponent]` attribute to your model class**
   - Optionally specify a custom component name: `[ObservableComponent("MyCustomName")]`
   - Default component name is `{ModelName}Component`

2. **Update your razor file to inherit from the generated component class**
   - Change `@inherits ObservableComponent<MyModel>` to `@inherits MyModelComponent`

## Examples

### Example 1: Direct Inheritance (Wrong)

```razor
@* Counter.razor *@
@inherits ObservableComponent<CounterModel>

<h3>Counter</h3>
<p>Count: @Model.Count</p>
<button @onclick="Model.IncrementCommand.Execute">Increment</button>
```

```csharp
// CounterModel.cs
[ObservableModelScope(ModelScope.Singleton)]
public partial class CounterModel : ObservableModel
{
    public partial int Count { get; set; }

    [ObservableCommand(nameof(Increment))]
    public partial IObservableCommand IncrementCommand { get; }

    private void Increment()
    {
        Count++;
    }
}
```

### Example 2: Correct Implementation

```csharp
// CounterModel.cs
[ObservableModelScope(ModelScope.Singleton)]
[ObservableComponent]  // ✅ Add this attribute
public partial class CounterModel : ObservableModel
{
    public partial int Count { get; set; }

    [ObservableCommand(nameof(Increment))]
    public partial IObservableCommand IncrementCommand { get; }

    private void Increment()
    {
        Count++;
    }
}

// Generated: CounterModelComponent.cs
public partial class CounterModelComponent : ObservableComponent<CounterModel>
{
    // Component implementation generated by source generator
}
```

```razor
@* Counter.razor *@
@inherits CounterModelComponent

<h3>Counter</h3>
<p>Count: @Model.Count</p>
<button @onclick="Model.IncrementCommand.Execute">Increment</button>
```

### Example 3: Custom Component Name

```csharp
// CounterModel.cs
[ObservableModelScope(ModelScope.Singleton)]
[ObservableComponent("CounterPage")]  // ✅ Custom name
public partial class CounterModel : ObservableModel
{
    public partial int Count { get; set; }

    [ObservableCommand(nameof(Increment))]
    public partial IObservableCommand IncrementCommand { get; }

    private void Increment()
    {
        Count++;
    }
}

// Generated: CounterPage.cs
public partial class CounterPage : ObservableComponent<CounterModel>
{
    // Component implementation generated by source generator
}
```

```razor
@* Counter.razor *@
@inherits CounterPage

<h3>Counter</h3>
<p>Count: @Model.Count</p>
<button @onclick="Model.IncrementCommand.Execute">Increment</button>
```

### Example 4: Non-Generic ObservableComponent

```razor
@* Layout.razor - WRONG *@
@inherits ObservableComponent

<div class="layout">
    @Body
</div>
```

Should be:

```csharp
// LayoutModel.cs
[ObservableModelScope(ModelScope.Singleton)]
[ObservableComponent("MainLayout")]
public partial class LayoutModel : ObservableModel
{
    // Model properties
}
```

```razor
@* Layout.razor - CORRECT *@
@inherits MainLayout

<div class="layout">
    @Body
</div>
```

## Why This Pattern?

The attribute-based approach provides several benefits:

1. **Separation of Concerns**: Model logic stays in the model, component infrastructure is generated
2. **Type Safety**: Generated components ensure correct model binding
3. **Extensibility**: You can extend the generated component class with additional logic
4. **Consistency**: Uniform pattern across all reactive components
5. **Code Generation**: Generator can add lifecycle hooks and subscriptions automatically

## Component Generation Details

When you add `[ObservableComponent]` to a model:

- **Generated Class Name**: `{ModelName}Component` (or custom name if specified)
- **Base Class**: Inherits from `ObservableComponent<TModel>`
- **Model Property**: Exposes the model via the `Model` property
- **Lifecycle Integration**: Automatic setup and teardown of reactive subscriptions
- **DI Integration**: Model is injected via dependency injection

## Migration Path

If you have existing components using direct inheritance:

1. Add `[ObservableComponent]` attribute to each model class
2. Build the project to generate component classes
3. Update each `.razor` file to inherit from the generated component
4. Remove the type parameter (e.g., `<CounterModel>` becomes just `CounterModelComponent`)

## Related Diagnostics

- RXBG009: Shared model not singleton
- RXBG041: DI service scope violation
